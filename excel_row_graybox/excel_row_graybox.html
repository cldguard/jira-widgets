<style>
/* ------------------------------ */
/* TABLE INTERACTIVITY */
/* ------------------------------ */

/* Default */
table[class^='offconn-'] td {
    cursor: default;
}

/* Pointer for data rows */
table[class^='offconn-'] tr:not(:first-child) td {
    cursor: pointer;
}

/* Hover highlight */
table[class^='offconn-'] tr:not(:first-child):hover td {
    background-color: #f5f5f5;
}


/* ------------------------------ */
/* GRAYBOX OVERLAY (hidden) */
/* ------------------------------ */
#offconn-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.3);
    z-index: 9999;
    display: none;
    align-items: center;
    justify-content: center;
}

#offconn-box {
    background-color: #f0f0f0;
    border: 1px solid #999;
    border-radius: 4px;
    padding: 12px 16px 16px 16px;
    min-width: 260px;
    max-width: 80%;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    font-family: Arial, sans-serif;
    font-size: 12px;
    position: relative;
}

#offconn-close {
    position: absolute;
    top: 4px;
    right: 8px;
    cursor: pointer;
    font-weight: bold;
    font-size: 14px;
}

#offconn-detail-table td {
    border-bottom: 1px solid #ccc;
    padding: 2px 4px;
}

#offconn-detail-table td:first-child {
    font-weight: bold;
    white-space: nowrap;
}

/* Scroll container for detail table to keep within viewport */
#offconn-scroll {
    max-width: 90vw;
    max-height: 80vh;
    overflow: auto; /* both vertical and horizontal */
    background: #fff;
    border: 1px solid #ccc;
}

/* Toolbar styles */
#offconn-toolbar {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-bottom: 8px;
}

#offconn-copy {
    font-size: 12px;
    padding: 4px 8px;
    cursor: pointer;
}
</style>


<!-- Graybox container -->
<div id="offconn-overlay">
    <div id="offconn-box">
        <span id="offconn-close">Ã—</span>
        <div style="font-weight:bold; margin-bottom:8px;">Row Details</div>
        <div id="offconn-toolbar">
            <button id="offconn-copy" type="button" title="Copy table as rich text">Copy</button>
        </div>
        <div id="offconn-scroll">
            <table id="offconn-detail-table" style="width:100%; border-collapse:collapse;"></table>
        </div>
    </div>
</div>


<script>
(function () {
    // Builds a URL based on the clicked field and row object.
    // Returns "" by default. Example: if clickedField === "App"
    // then it returns "https://google.com?" + encodeURIComponent(rowObj[clickedField])
    function link_builder(rowObj, clickedField) {
        let url = "";
        if (clickedField === "App" && rowObj[clickedField]) {
            url = "https://google.com?" + encodeURIComponent(rowObj[clickedField]);
        }
        return url;
    }

    // Copy the detail table as rich HTML to the clipboard (with fallbacks)
    async function copyTableAsRichText(tableEl) {
        const html = tableEl.outerHTML;
        const plain = tableEl.innerText || tableEl.textContent || "";
        // Preferred path: async clipboard API with HTML support
        try {
            if (navigator.clipboard && window.ClipboardItem) {
                const item = new ClipboardItem({
                    "text/html": new Blob([html], { type: "text/html" }),
                    "text/plain": new Blob([plain], { type: "text/plain" })
                });
                await navigator.clipboard.write([item]);
                return true;
            }
        } catch (e) {
            // fall through to other strategies
        }

        // Fallback: writeText (will copy HTML source as text if HTML type unsupported)
        try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(html);
                return true;
            }
        } catch (e2) {
            // fall through to execCommand fallback
        }

        // Legacy fallback: contenteditable selection + execCommand('copy')
        const sandbox = document.createElement("div");
        sandbox.setAttribute("contenteditable", "true");
        sandbox.style.position = "fixed";
        sandbox.style.left = "-9999px";
        sandbox.style.top = "0";
        sandbox.innerHTML = html;
        document.body.appendChild(sandbox);

        const range = document.createRange();
        range.selectNodeContents(sandbox);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        let success = false;
        try {
            success = document.execCommand("copy");
        } catch (e3) {
            success = false;
        }

        selection.removeAllRanges();
        document.body.removeChild(sandbox);
        return success;
    }

    function initOffconnTable(table) {
        if (!table || table.dataset.offconnBound === "1") return false;

        const headerRow = table.rows[0];
        if (!headerRow) return false;

        const headers = Array.from(headerRow.cells).map((cell) => cell.textContent.trim());

        const overlay = document.getElementById("offconn-overlay");
        const detailTable = document.getElementById("offconn-detail-table");
        const closeBtn = document.getElementById("offconn-close");
        const copyBtn = document.getElementById("offconn-copy");

        // Bind close button once
        if (closeBtn && !closeBtn.dataset.bound) {
            closeBtn.addEventListener("click", () => (overlay.style.display = "none"));
            closeBtn.dataset.bound = "1";
        }

        // Bind copy button once
        if (copyBtn && !copyBtn.dataset.bound) {
            copyBtn.addEventListener("click", async () => {
                const prev = copyBtn.textContent;
                copyBtn.disabled = true;
                try {
                    const ok = await copyTableAsRichText(detailTable);
                    copyBtn.textContent = ok ? "Copied" : "Copy failed";
                } catch (e) {
                    copyBtn.textContent = "Copy failed";
                } finally {
                    setTimeout(() => {
                        copyBtn.textContent = prev;
                        copyBtn.disabled = false;
                    }, 1200);
                }
            });
            copyBtn.dataset.bound = "1";
        }

        // Delegate clicks to table (works for rows added later too)
        table.addEventListener(
            "click",
            function (e) {
                const cell = e.target.closest("td");
                if (!cell) return;

                const row = cell.parentElement;
                if (!row || row.rowIndex === 0) return; // Skip header

                // Build JSON row object
                const rowObj = {};
                Array.from(row.cells).forEach((td, idx) => {
                    rowObj[headers[idx]] = td.textContent.trim();
                });

                const clickedField = headers[cell.cellIndex];

                // Populate popup
                detailTable.innerHTML = "";
                headers.forEach((header) => {
                    const tr = document.createElement("tr");

                    const keyCell = document.createElement("td");
                    keyCell.textContent = header;

            const valCell = document.createElement("td");
            if (header === clickedField) {
                tr.style.backgroundColor = "#e0e0e0";
                const url = link_builder(rowObj, clickedField);
                if (url) {
                    const a = document.createElement("a");
                    a.href = url;
                    a.target = "_blank";
                    a.rel = "noopener noreferrer";
                    a.textContent = rowObj[header];
                    valCell.appendChild(a);
                } else {
                    valCell.textContent = rowObj[header];
                }
            } else {
                valCell.textContent = rowObj[header];
            }

                    tr.appendChild(keyCell);
                    tr.appendChild(valCell);
                    detailTable.appendChild(tr);
                });

                overlay.style.display = "flex";
            },
            false
        );

        table.dataset.offconnBound = "1";
        return true;
    }

    function tryInitialize() {
        const table = document.querySelector("table[class^='offconn-']");
        if (table) {
            return initOffconnTable(table);
        }
        return false;
    }

    function setupObserver(timeoutMs = 30000) {
        const observer = new MutationObserver((mutations) => {
            for (const m of mutations) {
                for (const node of m.addedNodes) {
                    if (!(node instanceof Element)) continue;

                    // If the added node itself is the table
                    if (node.matches && node.matches("table[class^='offconn-']")) {
                        if (initOffconnTable(node)) {
                            observer.disconnect();
                            return;
                        }
                    }

                    // Or if the table exists within the added subtree
                    const found = node.querySelector && node.querySelector("table[class^='offconn-']");
                    if (found && initOffconnTable(found)) {
                        observer.disconnect();
                        return;
                    }
                }
            }
        });

        observer.observe(document.body || document.documentElement, {
            childList: true,
            subtree: true,
        });

        const timer = setTimeout(() => {
            observer.disconnect();
            console.warn("[offconn] Table not found within timeout; stopped observing.");
        }, timeoutMs);

        // In case it appears right after observing starts
        if (tryInitialize()) {
            observer.disconnect();
            clearTimeout(timer);
        }
    }

    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", () => {
            if (!tryInitialize()) {
                setupObserver();
            }
        });
    } else {
        if (!tryInitialize()) {
            setupObserver();
        }
    }
})();
</script>
